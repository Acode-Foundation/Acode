{
  "fund_management": {
    "primary_account": {
      "bank_name": "è¯é‚¦éŠ€è¡Œ",
      "bank_code": "803",
      "account_number": "061-50-7123481",
      "account_type": "ä¼æ¥­ä¸»å¸³æˆ¶",
      "purpose": "ä¸»è¦è³‡é‡‘æµé€šèˆ‡åˆ†æ½¤",
      "daily_limit": 1000000,
      "monthly_limit": 10000000
    },
    "payment_methods": {
      "visa_card": {
        "type": "Visaå•†å‹™å¡",
        "number": "4213-7800-5670-0836",
        "holder": "ä¼æ¥­å¸³æˆ¶",
        "purpose": "ç›´æ¥æ”¯ä»˜/ç·Šæ€¥æ”¯å‡º",
        "credit_limit": 200000,
        "daily_limit": 50000
      },
      "digital_wallets": [
        {
          "platform": "Line Pay",
          "account": "ä¼æ¥­å¸³è™Ÿ",
          "daily_limit": 100000
        },
        {
          "platform": "è¡—å£æ”¯ä»˜",
          "account": "ä¼æ¥­å¸³è™Ÿ", 
          "daily_limit": 100000
        }
      ]
    },
    "backup_accounts": [
      {
        "bank_name": "å‚™ç”¨éŠ€è¡Œ",
        "purpose": "é¢¨éšªåˆ†æ•£"
      }
    ]
  }
}// src/components/FundDashboard.vue
<template>
  <div class="fund-dashboard">
    <!-- å³æ™‚è³‡é‡‘æ¦‚æ³ -->
    <div class="real-time-overview">
      <h2>ğŸ’° å³æ™‚è³‡é‡‘æ¦‚æ³</h2>
      <div class="cards">
        <div class="card balance">
          <h3>ä¸»å¸³æˆ¶é¤˜é¡</h3>
          <div class="amount">TWD {{ formatCurrency(balance) }}</div>
          <div class="trend" :class="balanceTrend">
            <span>{{ balanceChange }}%</span>
          </div>
        </div>
        
        <div class="card available">
          <h3>å¯ç”¨è³‡é‡‘</h3>
          <div class="amount">TWD {{ formatCurrency(availableFunds) }}</div>
          <div class="progress">
            <div class="progress-bar" :style="{ width: utilizationRate + '%' }"></div>
          </div>
          <div class="utilization">åˆ©ç”¨ç‡: {{ utilizationRate }}%</div>
        </div>
        
        <div class="card pending">
          <h3>å¾…è™•ç†äº¤æ˜“</h3>
          <div class="amount">TWD {{ formatCurrency(pendingTransactions) }}</div>
          <div class="count">{{ pendingCount }} ç­†</div>
        </div>
      </div>
    </div>
    
    <!-- åˆ†æ½¤åˆ†é… -->
    <div class="profit-sharing">
      <h2>ğŸ¯ åˆ†æ½¤åˆ†é…ï¼ˆA-Eäº”é¡ï¼‰</h2>
      <div class="distribution-chart">
        <div class="category a">
          <div class="label">Aé¡ (40%)</div>
          <div class="bar" :style="{ height: categoryA.percentage + '%' }">
            <div class="amount">TWD {{ formatCurrency(categoryA.amount) }}</div>
          </div>
          <div class="status">{{ categoryA.status }}</div>
        </div>
        <!-- B-Eé¡é¡ä¼¼ -->
      </div>
      
      <div class="distribution-table">
        <table>
          <thead>
            <tr>
              <th>é¡åˆ¥</th>
              <th>æ¯”ä¾‹</th>
              <th>é‡‘é¡</th>
              <th>ç‹€æ…‹</th>
              <th>ä¸‹æ¬¡åˆ†é…</th>
              <th>æ“ä½œ</th>
            </tr>
          </thead>
          <tbody>
            <tr v-for="category in categories" :key="category.id">
              <td>{{ category.name }}</td>
              <td>{{ category.percentage }}%</td>
              <td>TWD {{ formatCurrency(category.amount) }}</td>
              <td>
                <span :class="['status', category.status]">
                  {{ category.statusText }}
                </span>
              </td>
              <td>{{ category.nextDistribution }}</td>
              <td>
                <button @click="viewCategoryDetails(category.id)">
                  è©³æƒ…
                </button>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
    
    <!-- äº¤æ˜“è¨˜éŒ„ -->
    <div class="transaction-history">
      <h2>ğŸ“‹ è¿‘æœŸäº¤æ˜“è¨˜éŒ„</h2>
      <div class="filters">
        <select v-model="filterType">
          <option value="all">æ‰€æœ‰äº¤æ˜“</option>
          <option value="income">æ”¶å…¥</option>
          <option value="expense">æ”¯å‡º</option>
          <option value="transfer">è½‰å¸³</option>
        </select>
        <input type="date" v-model="startDate">
        <input type="date" v-model="endDate">
        <button @click="exportTransactions">åŒ¯å‡ºCSV</button>
      </div>
      
      <div class="transactions">
        <div v-for="transaction in filteredTransactions" :key="transaction.id" 
             class="transaction" :class="transaction.type">
          <div class="date">{{ formatDate(transaction.date) }}</div>
          <div class="description">{{ transaction.description }}</div>
          <div class="category">{{ transaction.category }}</div>
          <div class="amount" :class="transaction.type">
            {{ transaction.type === 'income' ? '+' : '-' }}
            TWD {{ formatCurrency(transaction.amount) }}
          </div>
          <div class="balance">é¤˜é¡: TWD {{ formatCurrency(transaction.balance) }}</div>
        </div>
      </div>
    </div>
    
    <!-- è³‡é‡‘é æ¸¬ -->
    <div class="forecast">
      <h2>ğŸ”® è³‡é‡‘æµé æ¸¬</h2>
      <div class="chart-container">
        <canvas ref="forecastChart"></canvas>
      </div>
      <div class="forecast-summary">
        <div class="item">
          <div class="label">30å¤©é æ¸¬é¤˜é¡</div>
          <div class="value">TWD {{ formatCurrency(forecast.balance30d) }}</div>
        </div>
        <div class="item">
          <div class="label">é è¨ˆæ”¶å…¥</div>
          <div class="value">TWD {{ formatCurrency(forecast.estimatedIncome) }}</div>
        </div>
        <div class="item">
          <div class="label">é è¨ˆæ”¯å‡º</div>
          <div class="value">TWD {{ formatCurrency(forecast.estimatedExpenses) }}</div>
        </div>
        <div class="item warning" v-if="forecast.warning">
          <div class="label">âš ï¸ è³‡é‡‘é è­¦</div>
          <div class="value">{{ forecast.warningMessage }}</div>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
import { ref, computed, onMounted } from 'vue'
import axios from 'axios'
import Chart from 'chart.js/auto'

export default {
  name: 'FundDashboard',
  
  setup() {
    // éŸ¿æ‡‰å¼æ•¸æ“š
    const balance = ref(0)
    const availableFunds = ref(0)
    const pendingTransactions = ref(0)
    const categories = ref([])
    const transactions = ref([])
    const forecast = ref({})
    
    // è¨ˆç®—å±¬æ€§
    const utilizationRate = computed(() => {
      if (balance.value === 0) return 0
      return Math.round(((balance.value - availableFunds.value) / balance.value) * 100)
    })
    
    const filteredTransactions = computed(() => {
      return transactions.value.filter(t => {
        const matchesType = filterType.value === 'all' || t.type === filterType.value
        const matchesDate = (!startDate.value || t.date >= startDate.value) && 
                           (!endDate.value || t.date <= endDate.value)
        return matchesType && matchesDate
      })
    })
    
    // æ–¹æ³•
    const fetchFinancialData = async () => {
      try {
        const response = await axios.get('/api/financial/overview')
        balance.value = response.data.balance
        availableFunds.value = response.data.available
        pendingTransactions.value = response.data.pending
        categories.value = response.data.categories
        transactions.value = response.data.transactions
        forecast.value = response.data.forecast
      } catch (error) {
        console.error('ç²å–è²¡å‹™æ•¸æ“šå¤±æ•—:', error)
      }
    }
    
    const formatCurrency = (amount) => {
      return new Intl.NumberFormat('zh-TW').format(amount)
    }
    
    const formatDate = (dateString) => {
      return new Date(dateString).toLocaleDateString('zh-TW')
    }
    
    const exportTransactions = () => {
      const csv = transactionsToCSV(filteredTransactions.value)
      downloadCSV(csv, 'transactions.csv')
    }
    
    // åˆå§‹åŒ–åœ–è¡¨
    const initForecastChart = () => {
      const ctx = document.getElementById('forecastChart')
      new Chart(ctx, {
        type: 'line',
        data: {
          labels: forecast.value.labels,
          datasets: [
            {
              label: 'é æ¸¬é¤˜é¡',
              data: forecast.value.balances,
              borderColor: '#4CAF50',
              backgroundColor: 'rgba(76, 175, 80, 0.1)'
            },
            {
              label: 'é è¨ˆæ”¶å…¥',
              data: forecast.value.incomes,
              borderColor: '#2196F3',
              backgroundColor: 'rgba(33, 150, 243, 0.1)'
            },
            {
              label: 'é è¨ˆæ”¯å‡º',
              data: forecast.value.expenses,
              borderColor: '#F44336',
              backgroundColor: 'rgba(244, 67, 54, 0.1)'
            }
          ]
        },
        options: {
          responsive: true,
          plugins: {
            legend: {
              position: 'top'
            }
          }
        }
      })
    }
    
    // ç”Ÿå‘½é€±æœŸ
    onMounted(() => {
      fetchFinancialData()
      setInterval(fetchFinancialData, 300000) // æ¯5åˆ†é˜æ›´æ–°
    })
    
    return {
      balance,
      availableFunds,
      pendingTransactions,
      categories,
      transactions,
      forecast,
      utilizationRate,
      filteredTransactions,
      fetchFinancialData,
      formatCurrency,
      formatDate,
      exportTransactions,
      initForecastChart
    }
  }
}
</script>{
  "fund_management": {
    "primary_account": {
      "bank_name": "è¯é‚¦éŠ€è¡Œ",
      "bank_code": "803",
      "account_number": "061-50-7123481",
      "account_type": "ä¼æ¥­ä¸»å¸³æˆ¶",
      "purpose": "ä¸»è¦è³‡é‡‘æµé€šèˆ‡åˆ†æ½¤",
      "daily_limit": 1000000,
      "monthly_limit": 10000000
    },
    "payment_methods": {
      "visa_card": {
        "type": "Visaå•†å‹™å¡",
        "number": "4213-7800-5670-0836",
        "holder": "ä¼æ¥­å¸³æˆ¶",
        "purpose": "ç›´æ¥æ”¯ä»˜/ç·Šæ€¥æ”¯å‡º",
        "credit_limit": 200000,
        "daily_limit": 50000
      },
      "digital_wallets": [
        {
          "platform": "Line Pay",
          "account": "ä¼æ¥­å¸³è™Ÿ",
          "daily_limit": 100000
        },
        {
          "platform": "è¡—å£æ”¯ä»˜",
          "account": "ä¼æ¥­å¸³è™Ÿ", 
          "daily_limit": 100000
        }
      ]
    },
    "backup_accounts": [
      {
        "bank_name": "å‚™ç”¨éŠ€è¡Œ",
        "purpose": "é¢¨éšªåˆ†æ•£"
      }
    ]
  }
}# security/fund-security.yml
security_policies:
  authentication:
    multi_factor: true
    biometric_auth: true
    session_timeout: 900  # 15åˆ†é˜
    
  authorization:
    role_based_access:
      viewer: ["read_balance"]
      operator: ["read_balance", "initiate_transfer"]
      manager: ["read_balance", "initiate_transfer", "approve_transfer"]
      admin: ["all_permissions"]
    
    transfer_limits:
      daily: 1000000
      per_transaction: 500000
      manager_approval_threshold: 200000
      admin_approval_threshold: 500000
  
  monitoring:
    real_time_alerts:
      - large_transaction: "> 100000"
      - unusual_pattern: "æª¢æ¸¬ç•°å¸¸äº¤æ˜“æ¨¡å¼"
      - multiple_failed_attempts: "3æ¬¡ä»¥ä¸Šå¤±æ•—å˜—è©¦"
    
    audit_logging:
      enabled: true
      retention_days: 3650  # 10å¹´
      fields_logged:
        - user_id
        - action
        - amount
        - timestamp
        - ip_address
        - device_info
  
  encryption:
    data_at_rest: "AES-256"
    data_in_transit: "TLS 1.3"
    key_rotation: "90å¤©"
    hardware_security_module: true# bot/fund_notification_bot.py
import asyncio
import json
from datetime import datetime
import aiohttp
from typing import Dict, List, Optional

class FundNotificationBot:
    def __init__(self, config_path: str = "config/fund_bot.json"):
        """åˆå§‹åŒ–è³‡é‡‘é€šçŸ¥æ©Ÿå™¨äºº"""
        with open(config_path, 'r') as f:
            self.config = json.load(f)
        
        self.bank_api = self.config['bank_api']
        self.notification_channels = self.config['notification_channels']
        self.rules = self.config['notification_rules']
        
    async def monitor_funds(self):
        """ç›£æ§è³‡é‡‘ç‹€æ…‹"""
        while True:
            try:
                # ç²å–å³æ™‚æ•¸æ“š
                balance = await self.get_current_balance()
                transactions = await self.get_recent_transactions()
                alerts = await self.check_alerts(balance, transactions)
                
                if alerts:
                    await self.send_notifications(alerts)
                
                # æ¯5åˆ†é˜æª¢æŸ¥ä¸€æ¬¡
                await asyncio.sleep(300)
                
            except Exception as e:
                print(f"ç›£æ§éŒ¯èª¤: {e}")
                await asyncio.sleep(60)  # éŒ¯èª¤æ™‚ç­‰å¾…1åˆ†é˜
    
    async def check_alerts(self, balance: float, transactions: List[Dict]) -> List[Dict]:
        """æª¢æŸ¥è­¦å ±æ¢ä»¶"""
        alerts = []
        
        # é¤˜é¡ä½æ–¼é–¾å€¼
        if balance < self.rules['low_balance_threshold']:
            alerts.append({
                'type': 'low_balance',
                'message': f'âš ï¸ é¤˜é¡ä½æ–¼è­¦æˆ’ç·š: TWD {balance:,}',
                'priority': 'high'
            })
        
        # å¤§é¡äº¤æ˜“è­¦å ±
        large_transactions = [
            t for t in transactions 
            if t['amount'] > self.rules['large_transaction_threshold']
        ]
        
        for transaction in large_transactions:
            alerts.append({
                'type': 'large_transaction',
                'message': f'ğŸ’° å¤§é¡äº¤æ˜“: TWD {transaction["amount"]:,} - {transaction["description"]}',
                'priority': 'medium'
            })
        
        # ç•°å¸¸äº¤æ˜“æ¨¡å¼
        if await self.detect_anomaly_pattern(transactions):
            alerts.append({
                'type': 'anomaly_pattern',
                'message': 'ğŸš¨ æª¢æ¸¬åˆ°ç•°å¸¸äº¤æ˜“æ¨¡å¼',
                'priority': 'critical'
            })
        
        return alerts
    
    async def send_notifications(self, alerts: List[Dict]):
        """ç™¼é€é€šçŸ¥åˆ°å„æ¸ é“"""
        for alert in alerts:
            # ç™¼é€åˆ°Telegram
            if 'telegram' in self.notification_channels:
                await self.send_telegram(alert)
            
            # ç™¼é€åˆ°Slack
            if 'slack' in self.notification_channels:
                await self.send_slack(alert)
            
            # ç™¼é€éƒµä»¶
            if 'email' in self.notification_channels:
                await self.send_email(alert)
            
            # ç·Šæ€¥æƒ…æ³ç™¼é€ç°¡è¨Š
            if alert['priority'] == 'critical':
                await self.send_sms(alert)
    
    async def send_telegram(self, alert: Dict):
        """ç™¼é€Telegramé€šçŸ¥"""
        message = f"""
ğŸ”” è³‡é‡‘è­¦å ±
é¡å‹: {alert['type']}
è¨Šæ¯: {alert['message']}
æ™‚é–“: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
        """
        
        async with aiohttp.ClientSession() as session:
            await session.post(
                f"https://api.telegram.org/bot{self.config['telegram_bot_token']}/sendMessage",
                json={
                    'chat_id': self.config['telegram_chat_id'],
                    'text': message,
                    'parse_mode': 'HTML'
                }
            )
    
    async def send_slack(self, alert: Dict):
        """ç™¼é€Slacké€šçŸ¥"""
        color_map = {
            'critical': '#ff0000',
            'high': '#ff9900',
            'medium': '#ffff00',
            'low': '#00ff00'
        }
        
        payload = {
            "attachments": [{
                "color": color_map.get(alert['priority'], '#cccccc'),
                "title": f"è³‡é‡‘è­¦å ±: {alert['type']}",
                "text": alert['message'],
                "fields": [
                    {
                        "title": "å„ªå…ˆç´š",
                        "value": alert['priority'],
                        "short": True
                    },
                    {
                        "title": "æ™‚é–“",
                        "value": datetime.now().strftime('%H:%M:%S'),
                        "short": True
                    }
                ],
                "footer": "AAEC v8.0 è³‡é‡‘ç®¡ç†ç³»çµ±"
            }]
        }
        
        async with aiohttp.ClientSession() as session:
            await session.post(
                self.config['slack_webhook_url'],
                json=payload
            )
    
    async def generate_daily_report(self):
        """ç”Ÿæˆæ¯æ—¥å ±å‘Š"""
        report = {
            'date': datetime.now().strftime('%Y-%m-%d'),
            'start_balance': await self.get_start_of_day_balance(),
            'end_balance': await self.get_current_balance(),
            'total_income': await self.get_daily_income(),
            'total_expenses': await self.get_daily_expenses(),
            'transactions_count': await self.get_daily_transactions_count(),
            'profit_sharing': await self.calculate_daily_profits(),
            'alerts_today': self.todays_alerts
        }
        
        # ä¿å­˜å ±å‘Š
        report_filename = f"reports/daily-{datetime.now().strftime('%Y%m%d')}.json"
        with open(report_filename, 'w') as f:
            json.dump(report, f, indent=2)
        
        # ç™¼é€å ±å‘Š
        await self.send_report(report)
        
        return report
